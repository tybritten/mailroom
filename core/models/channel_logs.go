package models

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"slices"
	"time"

	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/nyaruka/gocommon/httpx"
	"github.com/nyaruka/gocommon/jsonx"
	"github.com/nyaruka/mailroom/runtime"
	"github.com/nyaruka/mailroom/utils/clogs"
)

// ChannelLogID is our type for a channel log id
type ChannelLogID int64

const (
	ChannelLogTypeIVRStart    clogs.Type = "ivr_start"
	ChannelLogTypeIVRIncoming clogs.Type = "ivr_incoming"
	ChannelLogTypeIVRCallback clogs.Type = "ivr_callback"
	ChannelLogTypeIVRStatus   clogs.Type = "ivr_status"
	ChannelLogTypeIVRHangup   clogs.Type = "ivr_hangup"
)

// ChannelLog stores the HTTP traces and errors generated by an interaction with a channel.
type ChannelLog struct {
	*clogs.Log

	channel  *Channel
	attached bool
}

// NewChannelLog creates a new channel log with the given type and channel
func NewChannelLog(t clogs.Type, ch *Channel, redactVals []string) *ChannelLog {
	return newChannelLog(t, ch, nil, redactVals)
}

// NewChannelLogForIncoming creates a new channel log for an incoming request
func NewChannelLogForIncoming(t clogs.Type, ch *Channel, r *httpx.Recorder, redactVals []string) *ChannelLog {
	return newChannelLog(t, ch, r, redactVals)
}

func newChannelLog(t clogs.Type, ch *Channel, r *httpx.Recorder, redactVals []string) *ChannelLog {
	return &ChannelLog{
		Log:     clogs.New(t, r, redactVals),
		channel: ch,
	}
}

// if we have an error or a non 2XX/3XX http response then log is considered an error
func (l *ChannelLog) isError() bool {
	if len(l.Errors) > 0 {
		return true
	}

	for _, l := range l.HttpLogs {
		if l.StatusCode < 200 || l.StatusCode >= 400 {
			return true
		}
	}

	return false
}

const sqlInsertChannelLog = `
INSERT INTO channels_channellog( uuid,  channel_id,  log_type,  http_logs,  errors,  is_error,  elapsed_ms,  created_on)
                         VALUES(:uuid, :channel_id, :log_type, :http_logs, :errors, :is_error, :elapsed_ms, :created_on)
  RETURNING id`

// channel log to be inserted into the database
type dbChannelLog struct {
	ID        ChannelLogID    `db:"id"`
	UUID      clogs.UUID      `db:"uuid"`
	ChannelID ChannelID       `db:"channel_id"`
	Type      clogs.Type      `db:"log_type"`
	HTTPLogs  json.RawMessage `db:"http_logs"`
	Errors    json.RawMessage `db:"errors"`
	IsError   bool            `db:"is_error"`
	ElapsedMS int             `db:"elapsed_ms"`
	CreatedOn time.Time       `db:"created_on"`
}

// InsertChannelLogs writes the given channel logs to the db
func InsertChannelLogs(ctx context.Context, rt *runtime.Runtime, logs []*ChannelLog) error {
	// write all logs to DynamoDB
	for batch := range slices.Chunk(logs, 25) {
		writeReqs := make([]types.WriteRequest, len(batch))

		for i, l := range batch {
			d, err := l.MarshalDynamo()
			if err != nil {
				return fmt.Errorf("error marshalling log: %w", err)
			}
			writeReqs[i] = types.WriteRequest{PutRequest: &types.PutRequest{Item: d}}
		}

		resp, err := rt.Dynamo.Client.BatchWriteItem(ctx, &dynamodb.BatchWriteItemInput{
			RequestItems: map[string][]types.WriteRequest{rt.Dynamo.TableName("ChannelLogs"): writeReqs},
		})
		if err != nil {
			return fmt.Errorf("error writing logs to dynamo: %w", err)
		}
		if len(resp.UnprocessedItems) > 0 {
			// TODO shouldn't happend.. but need to figure out how we would retry these
			slog.Error("unprocessed items writing logs to dynamo", "count", len(resp.UnprocessedItems))
		}
	}

	unattached := make([]*dbChannelLog, 0, len(logs))

	for _, l := range logs {
		if !l.attached {
			// if log isn't attached to a message or call we need to write it to the db so that it's retrievable
			unattached = append(unattached, &dbChannelLog{
				UUID:      l.UUID,
				ChannelID: l.channel.ID(),
				Type:      l.Type,
				HTTPLogs:  jsonx.MustMarshal(l.HttpLogs),
				Errors:    jsonx.MustMarshal(l.Errors),
				IsError:   l.isError(),
				CreatedOn: l.CreatedOn,
				ElapsedMS: int(l.Elapsed / time.Millisecond),
			})
		}
	}

	if len(unattached) > 0 {
		err := BulkQuery(ctx, "insert channel log", rt.DB, sqlInsertChannelLog, unattached)
		if err != nil {
			return fmt.Errorf("error inserting unattached channel logs: %w", err)
		}
	}

	return nil
}
